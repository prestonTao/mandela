package doubleratchet

import (
	"encoding/hex"
	"fmt"
	"testing"
)

func TestExample(t *testing.T) {
	// The shared key both parties have already agreed upon before the communication.
	sk := [32]byte{
		0xeb, 0x8, 0x10, 0x7c, 0x33, 0x54, 0x0, 0x20,
		0xe9, 0x4f, 0x6c, 0x84, 0xe4, 0x39, 0x50, 0x5a,
		0x2f, 0x60, 0xbe, 0x81, 0xa, 0x78, 0x8b, 0xeb,
		0x1e, 0x2c, 0x9, 0x8d, 0x4b, 0x4d, 0xc1, 0x40,
	}

	fmt.Println("共享密钥", hex.EncodeToString(sk[:]))

	// Diffie-Hellman key pair generated by one of the parties during key exchange or
	// by any other means. The public key MUST be sent to another party for initialization
	// before the communication begins.
	//创建DH密钥对。在通信开始之前，必须将公钥发送给另一方进行初始化。
	keyPair, err := DefaultCrypto{}.GenerateDH()
	if err != nil {
		log.Fatal(err)
	}
	// fmt.Println("keyPair", hex.EncodeToString(keyPair.PublicKey()), hex.EncodeToString(keyPair.PrivateKey()))

	// Bob MUST be created with the shared secret and a DH key pair.
	//Bob创建棘轮必须使用共享密钥和自己的DH密钥对。
	bob, err := New([]byte("bob-session-id"), sk, keyPair, nil)
	if err != nil {
		log.Fatal(err)
	}

	// Alice MUST be created with the shared secret and Bob's public key.
	//Alice创建棘轮必须使用共享密钥和Bob的公钥。
	alice, err := NewWithRemoteKey([]byte("alice-session-id"), sk, keyPair.PublicKey(), nil)
	if err != nil {
		log.Fatal(err)
	}

	// Alice can now encrypt messages under the Double Ratchet session.
	m, err := alice.RatchetEncrypt([]byte("Hi Bob!"), nil)
	if err != nil {
		log.Fatal(err)
	}
	// fmt.Println(string(m.Header))

	// Which Bob can decrypt.
	plaintext, err := bob.RatchetDecrypt(m, nil)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(string(plaintext))

	//---------------------

	m1, err := alice.RatchetEncrypt([]byte("nihao 1"), nil)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("m1 header", m1.Header)

	m2, err := alice.RatchetEncrypt([]byte("nihao 2"), nil)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("m2 header", m2.Header)

	// Which Bob can decrypt.
	plaintext, err = bob.RatchetDecrypt(m2, nil)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(plaintext))

	// Which Bob can decrypt.
	plaintext, err = bob.RatchetDecrypt(m1, nil)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(string(plaintext))

	//---------------------
	alice_m1, _ := bob.RatchetEncrypt([]byte("你好啊 alice 1"), nil)
	fmt.Println("alice_m1 header", alice_m1.Header)

	plaintext, _ = alice.RatchetDecrypt(alice_m1, nil)
	fmt.Println("alice_m1", string(plaintext))

	alice_m2, _ := bob.RatchetEncrypt([]byte("你好啊 alice 2"), nil)
	fmt.Println("alice_m2 header", alice_m2.Header)

	plaintext, _ = alice.RatchetDecrypt(alice_m2, nil)
	fmt.Println("alice_m2", string(plaintext))
}

func TestExample2(t *testing.T) {
	//实现BOB给ALICE发送加密消息，BOB --> ALICE
	//第一步，各自创建自己的密钥对
	bobKeyPair, _ := DefaultCrypto{}.GenerateDH()
	// aliceKeyPair, _ := DefaultCrypto{}.GenerateDH()
	//第二步，协商密钥
	sk := [32]byte{
		0xeb, 0x8, 0x10, 0x7c, 0x33, 0x54, 0x0, 0x20,
		0xe9, 0x4f, 0x6c, 0x84, 0xe4, 0x39, 0x50, 0x5a,
		0x2f, 0x60, 0xbe, 0x81, 0xa, 0x78, 0x8b, 0xeb,
		0x1e, 0x2c, 0x9, 0x8d, 0x4b, 0x4d, 0xc1, 0x40,
	}
	fmt.Println("共享密钥", hex.EncodeToString(sk[:]))

	//第三步，创建通道
	//alice使用bob的公钥创建一个session
	bob, _ := NewWithRemoteKey([]byte("bob-session-id"), sk, bobKeyPair.PublicKey(), nil)
	//bob使用协商密钥建立alice的session
	alice, _ := New([]byte("bob-session-id"), sk, bobKeyPair, nil)

	//第四步，通信
	hello_alice, _ := alice.RatchetEncrypt([]byte("你好啊 alice 1"), nil)
	bs, _ := bob.RatchetDecrypt(hello_alice, nil)
	fmt.Println(string(bs))

	hello_alice2, _ := alice.RatchetEncrypt([]byte("你好啊 alice 1"), nil)
	bs2, _ := bob.RatchetDecrypt(hello_alice2, nil)
	fmt.Println(string(bs2))
	//对比加密后的消息不一样
	fmt.Println(hex.EncodeToString(hello_alice.Ciphertext), "\n", hex.EncodeToString(hello_alice2.Ciphertext))

	//尝试跳过几条消息
	for i := 0; i < 3000000; i++ {
		// fmt.Println("第", i, "个解析")
		hello_alice, _ = alice.RatchetEncrypt([]byte("你好啊 alice n"), nil)
		bs, _ = bob.RatchetDecrypt(hello_alice, nil)
	}
	fmt.Println("解析跳过后的消息内容", string(bs))
}

func TestExample3(t *testing.T) {
	//为了创建一个头加密的会话，各方应该同意3个不同的共享密钥
	var (
		// The key for message keys derivation.
		sk = [32]byte{
			0xeb, 0x8, 0x10, 0x7c, 0x33, 0x54, 0x0, 0x20,
			0xe9, 0x4f, 0x6c, 0x84, 0xe4, 0x39, 0x50, 0x5a,
			0x2f, 0x60, 0xbe, 0x81, 0xa, 0x78, 0x8b, 0xeb,
			0x1e, 0x2c, 0x9, 0x8d, 0x4b, 0x4d, 0xc1, 0x40,
		}

		// Header encryption keys.
		sharedHka = [32]byte{
			0xbd, 0x29, 0x18, 0xcb, 0x18, 0x6c, 0x26, 0x32,
			0xd5, 0x82, 0x41, 0x2d, 0x11, 0xa4, 0x55, 0x87,
			0x1e, 0x5b, 0xa3, 0xb5, 0x5a, 0x6d, 0xe1, 0x97,
			0xde, 0xf7, 0x5e, 0xc3, 0xf2, 0xec, 0x1d, 0xd,
		}
		sharedNhkb = [32]byte{
			0x32, 0x89, 0x3a, 0xed, 0x4b, 0xf0, 0xbf, 0xc1,
			0xa5, 0xa9, 0x53, 0x73, 0x5b, 0xf9, 0x76, 0xce,
			0x70, 0x8e, 0xe1, 0xa, 0xed, 0x98, 0x1d, 0xe3,
			0xb4, 0xe9, 0xa9, 0x88, 0x54, 0x94, 0xaf, 0x23,
		}
	)

	keyPair, _ := DefaultCrypto{}.GenerateDH()

	bob, _ := NewHE(sk, sharedHka, sharedNhkb, keyPair)

	alice, _ := NewHEWithRemoteKey(sk, sharedHka, sharedNhkb, keyPair.PublicKey())

	m := alice.RatchetEncrypt([]byte("Hi Bob!"), nil)

	plaintext, _ := bob.RatchetDecrypt(m, nil)

	fmt.Println(string(plaintext))
}
